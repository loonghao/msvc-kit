//! Environment setup and activation script generation

use std::collections::HashMap;
use std::path::PathBuf;

use crate::error::{MsvcKitError, Result};
use crate::installer::InstallInfo;
use crate::version::Architecture;

use super::{get_env_vars, MsvcEnvironment};

/// Setup MSVC environment from installation info
///
/// Creates an `MsvcEnvironment` configuration from the provided
/// installation information.
pub fn setup_environment(
    msvc_info: &InstallInfo,
    sdk_info: Option<&InstallInfo>,
) -> Result<MsvcEnvironment> {
    let host_arch = Architecture::host();
    MsvcEnvironment::from_install_info(msvc_info, sdk_info, host_arch)
}

/// Apply environment variables to the current process
///
/// This sets the environment variables in the current process,
/// allowing subsequent commands to use the MSVC toolchain.
pub fn apply_environment(env: &MsvcEnvironment) -> Result<()> {
    let vars = get_env_vars(env);

    for (key, value) in vars {
        if key == "PATH" {
            // Prepend to existing PATH
            let current_path = std::env::var("PATH").unwrap_or_default();
            let new_path = format!("{};{}", value, current_path);
            std::env::set_var("PATH", new_path);
        } else {
            std::env::set_var(&key, &value);
        }
    }

    Ok(())
}

/// Generate an activation script for the shell
///
/// Creates a script that can be sourced/executed to set up the
/// MSVC environment in a new shell session.
pub fn generate_activation_script(env: &MsvcEnvironment, shell: ShellType) -> String {
    let vars = get_env_vars(env);

    match shell {
        ShellType::Cmd => generate_cmd_script(&vars),
        ShellType::PowerShell => generate_powershell_script(&vars),
        ShellType::Bash => generate_bash_script(&vars),
    }
}

/// Shell type for activation script generation
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ShellType {
    /// Windows Command Prompt (cmd.exe)
    Cmd,
    /// PowerShell
    PowerShell,
    /// Bash/sh (for Git Bash, WSL, etc.)
    Bash,
}

impl ShellType {
    /// Detect the current shell type
    pub fn detect() -> Self {
        // Check for PowerShell
        if std::env::var("PSModulePath").is_ok() {
            return ShellType::PowerShell;
        }

        // Check for bash
        if std::env::var("BASH").is_ok()
            || std::env::var("SHELL")
                .map(|s| s.contains("bash"))
                .unwrap_or(false)
        {
            return ShellType::Bash;
        }

        // Default to cmd on Windows
        #[cfg(windows)]
        return ShellType::Cmd;

        #[cfg(not(windows))]
        return ShellType::Bash;
    }

    /// Get the file extension for this shell's scripts
    pub fn script_extension(&self) -> &'static str {
        match self {
            ShellType::Cmd => "bat",
            ShellType::PowerShell => "ps1",
            ShellType::Bash => "sh",
        }
    }
}

fn generate_cmd_script(vars: &HashMap<String, String>) -> String {
    let mut script = String::from("@echo off\r\n");
    script.push_str("REM MSVC Environment Setup Script\r\n");
    script.push_str("REM Generated by msvc-kit\r\n\r\n");

    for (key, value) in vars {
        if key == "PATH" {
            script.push_str(&format!("set \"PATH={};%PATH%\"\r\n", value));
        } else {
            script.push_str(&format!("set \"{}={}\"\r\n", key, value));
        }
    }

    script.push_str("\r\necho MSVC environment configured successfully.\r\n");
    script.push_str("echo cl.exe is now available in PATH.\r\n");

    script
}

fn generate_powershell_script(vars: &HashMap<String, String>) -> String {
    let mut script = String::from("# MSVC Environment Setup Script\n");
    script.push_str("# Generated by msvc-kit\n\n");

    for (key, value) in vars {
        // Escape backslashes for PowerShell
        let escaped_value = value.replace('\\', "\\\\");

        if key == "PATH" {
            script.push_str(&format!(
                "$env:PATH = \"{};$env:PATH\"\n",
                escaped_value.replace("\\\\", "\\")
            ));
        } else {
            script.push_str(&format!(
                "$env:{} = \"{}\"\n",
                key,
                escaped_value.replace("\\\\", "\\")
            ));
        }
    }

    script.push_str(
        "\nWrite-Host \"MSVC environment configured successfully.\" -ForegroundColor Green\n",
    );
    script.push_str("Write-Host \"cl.exe is now available in PATH.\" -ForegroundColor Green\n");

    script
}

fn generate_bash_script(vars: &HashMap<String, String>) -> String {
    let mut script = String::from("#!/bin/bash\n");
    script.push_str("# MSVC Environment Setup Script\n");
    script.push_str("# Generated by msvc-kit\n\n");

    for (key, value) in vars {
        // Convert Windows paths to Unix-style for Git Bash/WSL
        let unix_value = value
            .replace('\\', "/")
            .replace("C:", "/c")
            .replace("D:", "/d");

        if key == "PATH" {
            script.push_str(&format!("export PATH=\"{}:$PATH\"\n", unix_value));
        } else {
            script.push_str(&format!("export {}=\"{}\"\n", key, unix_value));
        }
    }

    script.push_str("\necho \"MSVC environment configured successfully.\"\n");
    script.push_str("echo \"cl.exe is now available in PATH.\"\n");

    script
}

/// Save activation script to a file
pub async fn save_activation_script(
    env: &MsvcEnvironment,
    shell: ShellType,
    output_dir: &PathBuf,
) -> Result<PathBuf> {
    let script = generate_activation_script(env, shell);
    let filename = format!("activate.{}", shell.script_extension());
    let path = output_dir.join(&filename);

    tokio::fs::create_dir_all(output_dir).await?;
    tokio::fs::write(&path, script).await?;

    Ok(path)
}

/// Write environment variables to Windows registry (user level)
#[cfg(windows)]
pub fn write_to_registry(env: &MsvcEnvironment) -> Result<()> {
    use winreg::enums::*;
    use winreg::RegKey;

    let hkcu = RegKey::predef(HKEY_CURRENT_USER);
    let (env_key, _) = hkcu
        .create_subkey("Environment")
        .map_err(|e| MsvcKitError::EnvSetup(format!("Failed to open registry: {}", e)))?;

    let vars = get_env_vars(env);

    for (key, value) in vars {
        if key == "PATH" {
            // Append to existing PATH
            let current: String = env_key.get_value("Path").unwrap_or_default();
            let new_path = if current.is_empty() {
                value
            } else {
                format!("{};{}", value, current)
            };
            env_key
                .set_value("Path", &new_path)
                .map_err(|e| MsvcKitError::EnvSetup(format!("Failed to set PATH: {}", e)))?;
        } else {
            env_key
                .set_value(&key, &value)
                .map_err(|e| MsvcKitError::EnvSetup(format!("Failed to set {}: {}", key, e)))?;
        }
    }

    // Broadcast environment change
    broadcast_environment_change();

    Ok(())
}

#[cfg(windows)]
fn broadcast_environment_change() {
    // This would require winapi crate for proper implementation
    // For now, just log that a restart may be needed
    tracing::info!("Environment variables updated. You may need to restart your terminal.");
}

#[cfg(not(windows))]
pub fn write_to_registry(_env: &MsvcEnvironment) -> Result<()> {
    Err(MsvcKitError::UnsupportedPlatform(
        "Registry operations are only supported on Windows".to_string(),
    ))
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_shell_type_detect() {
        // Just ensure it doesn't panic
        let _ = ShellType::detect();
    }

    #[test]
    fn test_script_extension() {
        assert_eq!(ShellType::Cmd.script_extension(), "bat");
        assert_eq!(ShellType::PowerShell.script_extension(), "ps1");
        assert_eq!(ShellType::Bash.script_extension(), "sh");
    }

    #[test]
    fn test_generate_cmd_script() {
        let mut vars = HashMap::new();
        vars.insert("TEST".to_string(), "value".to_string());

        let script = generate_cmd_script(&vars);
        assert!(script.contains("set \"TEST=value\""));
    }

    #[test]
    fn test_generate_powershell_script() {
        let mut vars = HashMap::new();
        vars.insert("TEST".to_string(), "value".to_string());

        let script = generate_powershell_script(&vars);
        assert!(script.contains("$env:TEST"));
    }
}
